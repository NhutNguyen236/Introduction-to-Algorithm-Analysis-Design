# -*- coding: utf-8 -*-
"""Brute_force.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10MLLzwbAAAx8cXL_05mchySiiJtOSX7j

# Auto-generate array function
"""

from numpy.random import seed
from numpy.random import randint

def auto_gen():
  # Using numpy libraryto auto-generate an array of integers 
  # Output: auto-generate an array of integers 
  array = randint(0,100,randint(1,10))

  return array

#Implementation
print(auto_gen())

"""# Selection sort algorithm"""

def sele_sort(A):
  #Sorts a given array by selection sort
  #Input: An array A[0..n − 1] of orderable elements
  #Output: Array A[0..n − 1] sorted in nondecreasing order

  # Get A length
  n = len(A)
  for i in range(0,n):
    min = i
    for j in range(i+1,n):
      if A[j] < A[min]:
        min = j
    A[i],A[min] = A[min],A[i]
  return A

#Implementation
A = auto_gen()
print(sele_sort(A))

"""## Note:

* Pseudo code in refereneced book is basically false in identifying the end point for the both loop if we are progrmming in Python
* Remember that, in Python `range` always has its end point at `n-1`

# Selection sort Run-time and run-time diagram
"""

import time 
import pylab 
import random

# Input for this method must be a method ... 
def time_sele_sort():
  input_size = []
  timer = []

  for i in range(2,100):
    input_size.append(i)
    temp = []
    for j in range(i):
      temp.append(random.randint(0,10))
    start = time.time()
    sele_sort(temp)
    end = time.time()

    timer.append((end-start) * 1000)
  
  pylab.plot(input_size,timer, 'o-')
  pylab.show()

#Implementation
time_sele_sort()

"""# Bubble sort algorithm"""

def bubble_sort(A):
  #Sorts a given array by bubble sort
  #Input: An array A[0..n − 1] of orderable elements
  #Output: Array A[0..n − 1] sorted in nondecreasing order

  # Get A length
  n = len(A)
  for i in range(0,n):
    for j in range(0,n-1-i):
      if A[j+1] < A[j]:
        A[j], A[j+1] = A[j+1], A[j]
  return A

#Implementation
A = auto_gen()
print(bubble_sort(A))

"""# Bubble sort Run-time and run-time diagram"""

import time 
import pylab 
import random

# Input for this method must be a method ... 
def time_bubble_sort():
  input_size = []
  timer = []

  for i in range(2,100):
    input_size.append(i)
    temp = []
    for j in range(i):
      temp.append(random.randint(0,10))
    start = time.time()
    bubble_sort(temp)
    end = time.time()

    timer.append((end-start) * 1000)
  
  pylab.plot(input_size,timer, 'o-')
  pylab.show()

#Implementation
time_bubble_sort()

"""# Sequential search algorithm"""

def seq_search(A,k):
  #Implements sequential search with a search key as a sentinel
  #Input: An array A of n elements and a search key K
  #Output: The index of the first element in A[0..n − 1] whose value is equal to K or −1 if no such element is found

  # Get A length
  n = len(A)

  last = A[n-1]

  A[n-1] = k
  i = 0

  pos = 0

  while(A[i] != k): 
    i += 1
  
  # Put the last element back to its own place
  A[n-1] = last
  if((i < n-1) or (k == A[n-1])): 
    pos = i
  else:
    pos = -1

  return pos

#Implementation
A = auto_gen()
print(A)
print(seq_search(A,3))

"""# Sequential search Run-time and run-time diagram"""

import time 
import pylab 
import random

# Input for this method must be a method ... 
def time_seq_search():
  input_size = []
  timer = []

  for i in range(2,100):
    input_size.append(i)
    temp = []
    for j in range(i):
      temp.append(random.randint(0,10))
    key = random.randint(0,10)
    start = time.time()
    seq_search(temp,key)
    end = time.time()

    timer.append((end-start) * 1000)
  
  pylab.plot(input_size,timer, 'o-')
  pylab.show()

#Implementation
time_seq_search()